\documentclass[12pt, oneside]{article}
\usepackage{amsmath, amsthm, amssymb, calrsfs, wasysym, verbatim,  color, graphics, geometry}
\usepackage{hyperref}
\geometry{tmargin=.75in, bmargin=.75in, lmargin=.75in, rmargin = .75in}
\usepackage[colorinlistoftodos,color=cyan]{todonotes}
\newcommand{\Hc}{\mathcal{H}}
\newcommand{\Rc}{\mathcal{R}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Cdot}{\boldsymbol{\cdot}}

\newtheorem{thm}{Theorem}
\newtheorem{defn}{Definition}
\newtheorem{conv}{Convention}
\newtheorem{rem}{Remark}
\newtheorem{lem}{Lemma}
\newtheorem{cor}{Corollary}


\title{Resume: }
\author{Matias Mazzanti}
\date{}

\begin{document}

\maketitle
\tableofcontents

\vspace{.25in}
\section{Comentarios}
\begin{itemize}
  \item Redes: Tanenbaum-Computer Network. La intro
  \item Arquitectura: Onur, Digital Design and Computer Architecture y Computer Architecture - ETH Zürich
\end{itemize}

Para la parte de CKKS:
\begin{itemize}
  \item https://blog.openmined.org/ckks-explained-part-1-simple-encoding-and-decoding/
  \item BFV: https://blog.openmined.org/build-an-homomorphic-encryption-scheme-from-scratch-with-python/
\end{itemize}
\section{Intro Matematica}
Una buena fuente de info puede ser la tesis de Yao Chen: Applying Fully Homomorphic
Encryption: Practices and Problems.

\subsection{Campos finitos o campos de Galois}
Para que algo sea un campo, tiene que ser conmutativo en la multiplicacion (y creo que en la suma),
cada elemento tiene que tener su inverso multiplicativo y ...
Entonces los numeros reales son un campo.
Encambio los numeros enteros no, ya que no siempre el inverso multiplicativo de un entero
es un entero.
Con esto aparece la nocion de campos finitos, la cual achica un poco el espacio para
permitir que esta propiedad valga y se pueda considerar un campo.

Basicamente se achica el espacio tomando modulo de un numero primo o potencia de un
numero primo.
Es decir en vez the tomar los enteros $\Z$, tomamos los enteros pero modulo $q$,
es decir $\Z_q$.
La condicion de q es para que todo elemento dentro de este espacio tengo inverso multiplicativo.
Si por ejemplo tomo $q=6$, que no cumple, voy a ver que 2 no tiene inverso multiplicativo.
Ya que cuando hago $2*n$ mod 6, donde $0 < n < q$, nunca da 1.

\subsection{Multiplicacion de polinomios}
Nos interesa el caso en el cual esta con modulo $q \in \Z$ y los algoritmos para hacerlo.

En el caso de modulo de un entero, simplemente significa que ese polinomio tiene coeficientes
menores a q-1 y mayores a 0.
En general para FHE, esto cambia y hace que los coeficientes esten en (-q/2,q/2]

\todo[inline]{Ir llenando a medida que se necesita, es un tema muy grande.}
\paragraph{Aritmetica modular}
La aritmética modular puede ser construida matemáticamente mediante la relación de
congruencia entre enteros, que es compatible con las operaciones en el anillo de enteros:
suma y multiplicación.
En general en criptografia se usa como modulo un numero primo.
\todo{por que?}
Para un determinado módulo n, ésta se define de la siguiente manera:

a y b se encuentran en la misma ''clase de congruencia'' módulo n, si ambos dejan
el mismo resto si los dividimos entre n, o, equivalentemente, si a - b es un multiplo de n.
\begin{align*}
a\equiv b (mod n)
\end{align*}
Los parentesis del modulo hacen referencia a que se aplica a toda la ecuacion y no
solo al lado derecho.
Si no tengo los parentesis es la operacion modulo, que seria un a determinado tal que
es el remanente al dividir b con n.

La relacion de congruencia tambien se puede escribir de la siguiente forma

\begin{align*}
  a = kn + b
\end{align*}
Lo que significa que
\begin{align*}
  &a = pn + r \\
  &b = qn + r
\end{align*}
Donde $0\leq r <n$ es el remanente comun.
Y si definimos $k=p-q$ llegamos a la ecuacion anterior.
%paper: 1988 Fast Fourier Transformation Based on Number Theoretic Transforms. doi:10.1016/0016-0032(88)90031-2 
\subsection{DFT}
Esto parece ser la clave de todo.


La idea general parece ser que todo el tema del anillo y demas se conoce
como un campo finito o campo de Galois.
Una forma de hacer multiplicaciones  de polinomios o de numeros muy grandes es
con la convolcion que se puede implementar con DFT (o algo asi...).
La version de DFT para este tipo de campos se conoce como NTT.


%Para NTT: http://www.apfloat.org/ntt.html
Falta entender como usan Number theoretic transform (NTT) y chinese remainder
theorem (CRT) en todo esto.
Que es la otra clave.

\paragraph{Number theoretic transforms (NTT)}:
NTT es basicamente una transformada de fourier discreta (DFT).
Una vez que un par de polinomios son transformados al dominio de ''frecuencia'',
su producto puede ser calculado simplemente en orden O(n) haciendo producto de elemento
a elemento, y si resultado se conviernte de vuelta con la transformacion inversa.
De esta forma el costo dominante de la multiplicacion polinomial viene por el costo
de la traformacion desde y hacia el dominio de frecuencia.
NTT tiene una complejidad de O(nlogn).
Hay muchos algoritmos de NTT, y segun el paper ''A note on the implementation of the Number
Theoretic Transform'' de ''Michael Scott'',  una buena estrategia es usar
el algoritmo de \textit{Cooley Tukey butterfly} para el caso de la transformacion
y cambiar al algoritmo de \textit{Gentleman-Sade butterfly} para la transformacion
inversa.
En general se usa modulo primo $q=1 mod 2n$ de forma que exista la 2n-esima raiz de
la unidad.
Donde $n$ es el grado del polinomio.

%Para CRT: http://www.dragonwins.com/domains/getteched/crypto/chinese_remainder_theorem.htm
%https://crypto.stanford.edu/pbc/notes/numbertheory/crt.html
%http://www.apfloat.org/crt.html
\paragraph{Chinese Remainder Theorem (CRT)}
CRT resuelve el problema de como encontrar x que es congruente a diferentes valores y modulos.
\todo{Por que esto es importante?}
Viene por algo de tener un modulo o polinomio muy grande (chequear) y dividirlo en
subproblemas y resolverlos tipo divde and conquer.

Es una forma de representar enteros muy grandes con pocos bits.
Represento el valor $N$ dando el valor mas grande posible $T$, con diferentes modulos $M_i$
coprimos y sus respectivos residuos $R_i$.
Donde $T=(M_1)(M_2)...(M_n)$.
Es decir hay que resolver
\begin{align*}
  &N \equiv R_1 (mod M_1) \\
  & N \equiv R_2 (mod M_2) \\
  & \hspace{0.5cm}... \\
  &N \equiv R_n (mod M_n)
\end{align*}

CRT te dice que pare resolverlo calculas (en el caso $n=3$):
\begin{align*}
  N = f(R_1,R_2,R_3) =  (I_1M_2M_3R_1 + M_1I_2M_3R_2 + M_1M_2I_3R_3) mod T
\end{align*}
Donde $I_i$ es el modulo $M_i$ inverso multiplicativo de $T/M_i$ (el producto
de todos los modulos a excepcion de $M_i$).

Es decir se calcula $I_1$ de la siguiente forma:
\begin{align*}
  I_1M_2M_3 \equiv 1 (mod M_1)
\end{align*}
Se reemplazan los $M_i$ y se calcula.
De la misma manera se calculan las demas $I_i$ y se reemplaza con CRT y se calcula N.

Creo que en esta representacion tambien se puede sumar y multiplicar.


Frase de stackoverflow: CRT-based representation is the internal representation
for some of the Number-Theoretic Transform (NTT) based algorithms for multiplication
\subsection{Extras}
\paragraph{Maximo comun divisor}: MCD

Mayor numero entero que divide a dos o mas numeros enteros sin dejar residuo.

Una forma de calcular es agarrar a los numeros y descomponerlos en factores primos de cada uno.
Voy dividiendo cada numero por numeros primos hasta llegar a 1.
Luego el MCD entre esos numeros es multiplicar por los numeros primos en comun, incluyendo
la cantidad de apariciones de cada uno.

\vspace{0.3cm}
\paragraph{CoPrimo}:
Dos numeros a y b, son coprimos si no tienen ningun factor primo en comun.
Se dice tambien que a es primo de b o que a es coprimo de b.
Es decir si no tienen otro divisor comun mas que 1 y -1.
Esto es igual a decir que su MCD entre los dos es igual a 1.
Para ser coprimos no hacen falta que sean ellos mismos numeros primos.

\textbf{Identidad de Bezout}: Si a y b son primos entre si (coprimos), entonces existen dos enteros x e y tal
que a*x+b*y=1.
\vspace{0.3cm}

\paragraph{Matriz de Vandermonde}:
Una matriz $V$ que para todo indice se cumple $V_{ij}=x_i^{j-1}$
El determinante del cuadrado de esta matriz se lo denomina \textbf{polinomio de Vandermonde}.
Esta esta dada por:
\begin{equation*}
  det(V) = \prod_{1\leq i < j \leq n}(x_j-x_i)
\end{equation*}
El cual no es cero solo si todos los $x_i$ son distintos.

\vspace{0.3cm}
\paragraph{Congruencia (teoria de numeros)}:
Si dos numeros a y b tienen el mismo resto al dividirlos por un numero natural
m distinto de cero, llamado modulo.
Se expresa de la siguiente forma:
\begin{equation*}
a \equiv b \text{ (mod } m)
\end{equation*}
a es congruente con b modulo m.
Esto lleva a la siguiente propiedad:
\begin{equation*}
  a = b + km
\end{equation*}
para algun $k\in \Z$


\vspace{0.3cm}
\paragraph{Modulo}:

\vspace{0.3cm}
\paragraph{Raiz enesima de la unidad}:
Cualquiera de los numeros compejos que satisfacen la ecuacion:
\begin{equation*}
  z^n=1
\end{equation*}
donde n es un entero mayor a 1.
Para cada n, las n diferentes raices n-esimas de la unidada son:
\begin{equation*}
  e^{2\pi ik/n} \text{ donde } k=0,1,2,...,n-1
\end{equation*}
Entre las raices enesimas de la unidad siempre esta el 1, y el numero -1 solo
esta cuando n es par y los numeros i e -i cuando n es multiplo de cuatro.
Las raices enesimas de la unidad no reales se presentan en pares de conjugados.

\vspace{0.3cm}
\paragraph{Raices primitivas}:

\subsection{Lattices}

Full rank: dada una matriz de $m x n$
\begin{itemize}
  \item $m<n$: es Full rank si las $m$ filas son linealmente independientes.
  \item $m>n$: es Full rank si las $n$ columnas son linealmente independientes.
  \item $m=n$: es Full rank si las columnas o filas (si son unas son las otras) son
    linealmente independientes.
\end{itemize}

Polinomio monico:
es un polinomio de variable única (es decir, un polinomio de una sola variable)
en el que el coeficiente principal (el coeficiente distinto de cero del grado más alto) es igual a 1.

\paragraph{Chinese Remainder Theorem On integer modulo n}
Si $n=pq$  donde $1<p,q$ y $p$ es coprimo de $q$, entonces $\Z_n$ puede ser descompuesto como
\begin{equation*}
  \Z_n \cong \Z_p\times \Z_q
\end{equation*}
Esta descomposicion es un isomorfismo: $\psi:\Z_n\to\Z_p\times\Z_q$.
Esto tiene como implicacion que dado $a,b \in\Z_n$ podemos encontrar $(a_p,a_q),(b_p,b_q)\in\Z_p\times\Z_q$
y asi tener
\begin{align}
  \psi(a+b)&=\psi(a)+\psi(b)\\
  \psi(a.b)&=\psi(a).\psi(b)
\end{align}
Esto es de uso ya que en general $n$ es muy grande y es mas eficiente
computar con la descomposicion (que se puede descomponer multiples veces).
Este teorema tambien vale para anillos polinomiales.

\paragraph{Raices primitivas}
En matemática, las raíces n-ésimas de la unidad, o números de de Moivre,
son todos los números complejos que dan 1 cuando son elevados a una potencia dada n.
Se puede demostrar que están localizados en el círculo unitario del plano complejo y
que en ese plano forman los vértices de un polígono regular de n lados con un vértice
sobre el punto 1 de dicho plano, siempre que $n>2$.

\paragraph{Polinomio ciclotimico}
Se denomina polinomio ciclotómico de orden n y se denota como $\phi_n$ al
polinomio monico cuyas raíces son todas las raíces primitivas de orden n de la unidad,
es decir, que verifican zn = 1, donde z es un número complejo.
Se llama raíz enésima de la unidad a cualquiera de los números complejos que
satisfacen:
\begin{align*}
  z^{n}=1
\end{align*}
donde $n\in\N$, $n>1$.

Para cada $n$, las $n$ diferentes raíces n-ésimas de la unidad son:
\begin{align*}
  e^{2\pi ik/n}
\end{align*}
 donde $k=0,1,2,\dots ,n-1$.

 Las raíces primitivas son de la forma $w_r$, con $0 \leq r < n$, r coprimo con n, y $\omega =e^{\frac {2i\pi }{n}}$
\begin{align*}
 \Phi _{n}=\prod _{{}_{r}}(X-\omega ^{r})
\end{align*}
 \paragraph{Función $\varphi$ de Euler}
 La función $\varphi$ de Euler (también llamada función indicatriz de Euler o función totiente)
 es una función importante en teoría de números.
 Si n es un número entero positivo,  entonces $\varphi(n)$ se define como la
 cantidad de enteros positivos $k$ menores a n y
 coprimos con a, es decir, formalmente se puede definir como:
 \begin{align*}
 \varphi(n)=|\{k\in \mathbb {N} |k\leq n\land \mathrm {mcd} (k,n)=1\}
 \end{align*}
 donde $|·|$ significa la cardinalidad del conjunto descrito.
 mcd es el maximo comun divisor y al ser igual a 1 quiere decir que son primos.

La función $\varphi$ es importante principalmente porque proporciona el tamaño del
grupo multiplicativo de enteros módulo n.
Más precisamente, $\varphi (n)$ es el orden del grupo de unidades del anillo
$\mathbb {Z} /n\mathbb {Z}$.

\subsection{Transformada de Fourier Discreta}
DFT se utiliza mucho en FHE.

\paragraph{Convolucion} %
\href{https://betterexplained.com/articles/intuitive-convolution/}{Convolution Intuition}

La convolución de $f$ y $g$, se denota $f*g$,.
Se define como la integral del producto de ambas
funciones después de desplazar una de ellas una distancia $t$.
\begin{align*}
(f*g)(t)\ {\stackrel {\mathrm {.} }{=}}\int _{-\infty }^{\infty }f(\eta )g(t-\eta )d\eta
\end{align*}
Cuando se multiplican dos polinomios, los coeficientes del producto están dados
por la convolución de las sucesiones originales de coeficientes, en el sentido dado
aquí (usando extensiones con ceros como se ha mencionado).

\subsection{Teoria de anillos}
Un anillo es un conjunto donde se puede sumar restar y multiplicar.
En algunos casos se pude dividir.

Ejemplo, los enteros $\Z$ con la suma y multiplicacion forman un anillo.
No simpre se puede dividir ya que si hago 1/2 el resultado ya no es un entero.

$\Z[x]$ es el conjutno de polinomios donde sus coefficientes son enteros.
Es una extension de $\Z$ en el sentido que permitimos que todos los enteros
mas un simbolo extra x, donde podemos multiplicar y sumar ($x^2, 2x^3$ etc).

Otro de interes es  $\Z/n\Z$. Los enteros mod n.
Son una clase equivalente de los enteros con la relacion de equivalencia de congruencia
modulo n.
Es exactamente el grupo ciclico de orden n.

Por ulitmo otro de interes es $\R[x]/(x^2+1)$.
Es tomar el anillo polinomial $\R[x]$ y hacer modulo por el polinomio $(x^2+1)$,
esto significa que ese polinomio se ponga a cero.
Ejemplo
\begin{equation*}
  (x+1)^2 = x^2 + 2x + 1 = 2x + (x^2 + 1) = 2x + 0 = 2x
\end{equation*}
Otra forma de pensarlo es que $x^2 = -1$

continuar con Ring Theory (Math 113) Summer 2016, James Mclvor, Berkeley.

\section{CKKS}
Info sacada de:
Notes on Lattices, Homomorphic Encryption, and CKKS
Vir Pathak
February 2022.
https://arxiv.org/pdf/2205.03511.pdf
\subsection{Codificacion}
Sea $M$ una potencia de 2.

El $M$-esimo polinomio ciclotomco $\Phi(X)$ de grado $N=\Phi(M)=M/2$.

Las raices de unidad $\xi=e^{2\pi i/M}$.

Se define el anillo $\Rc=\Z[X]/(\Phi_M(x))=\Z[X]/(X^M+1)$.

Definimo al encaje canonico $\sigma: \Rc\to\C^N$ como
$\sigma(m)=(m(\xi),...,m(\xi^j),...,m(\xi^{M-1}))$, donde j corre sobre todos los
numeros dentro de $\Z^*_M$.
Se puede ver que $\sigma(m)\in\C^N$ ya que $|\Z^*_M|=\Phi(M)=N$.

Nuestro mensaje es un vector complejo $\in\C^{N/2}$ y nuestro espacio de textoplano
es $\in\Rc$.
Gracias a esto podemos encriptar multiples mensajes en un unico texto cifrado.

Como cada $N$-esima raiz dela unidad es la compleja conjugada de otra
$N$-esima raiz de la unidad, sabemos que la imagen es:
\begin{equation*}
\sigma(\Rc)\subseteq\Hc=\{z\in\C^N|z_j=\overline{z_{-j}}\}
\end{equation*}

Entonces naturalmente podemos identificar cada elemento de $\sigma(\Rc)$ con $\C^{N/2}$.
Para ello agarramos a nuestro mensaje $z\in\C^{N/2}$ y lo extendemos a $\C^N$ computando
$\pi^{-1}(z)$ que agrega los complejos conjugados de $z$.

Como $\pi^{-1}(z)\in\Hc\subset\C^N$ nos gustaria aplicar inmediatamente $\sigma^{-1}$ para obtener nuestro
polinomio $\Rc$.
El problema es que $\sigma(\Rc)\neq\Hc$, entonces $\pi^{-1}(z)$ podria no ser un elemento de
$\sigma(\Rc)$.
Para solucionar este problema usamos la tecnica denominada coordinate-wise random rounding.
\subsubsection*{coordinate-wise random rounding}

\subsection{RNS}
% del propio paper de RNS ckks
For an efficient implementation of polynomial arithmetic, Gentry et al. [22]
suggested a representation of cyclotomic polynomials, called the double-CRT representation,
based on the Chinese Remainder Theorem(CRT).
The first CRT layer uses the Residue Number System (RNS) in order to decompose a
polynomial into a tuple of polynomials with smaller moduli.
The second layer converts each of small polynomials into a vector of modulo integers
via the Number Theoretic Transform (NTT).
In the double-CRT representation, an arbitrary polynomial is identified with a
matrix consisting of small integers, and this enables an efficient polynomial arithmetic
by performing component-wise modulo operations.
\subsection{dudas}
\begin{enumerate}
  \item Como y por que elijo parametros como h?
  \item El factor de escaleo es para usar valores enteros?
  \item Por que se usan anillos?
  \item Por que el mapeo canonico es similar al DFT?
  \item Como se usa el teorema chino del remanente?
  \item Eso es lo que se conoce como CKKS RNS ? (Residue Number System)
  \item RNS: double-CRT representation of cyclotomic polynomial ring elements.
  \item NTT: que es y su uso.
  \item Como lleno el espacio del vector cuando mi input no es N/2?
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Codificacion}

La gracia de la codificacion es poder codificar muchos inputs en una unica codificacion.
En este esquema usan polinomios.
Luego se encripta ese polinomio para garatnizar la seguridad.

Vamos a tener un input $z\in \mathbb{C}^{N/2}$, recordando que $N$ va ser el tamaño
del polinomio que vamos a tener, y $N/2$ el tamaño de nuestro input.
La codificacion nos va a pasar a un polinomio $m(X)\in \mathbb{Z}[X]/(X^N+1)$.
A este espacio polinomial lo vamos a denotar como $R= \mathbb{Z}[X]/(X^N+1)$.

Toda la codificacion y demas va a usar las raices del polinomio ciclotomico $\Phi_M(X)=
X^N+1$.
Con $M=2N$.
Estas raices no son mas que potencias de $\xi_M=e^{2i\pi/M}$.
La idea de la decodificacion es que dado nuestro polinomio $m(X)$ lo vamos a evaluar en dichas
raices, y nos iran dando los diferentes decodificaciones.
Esto lo vamos a denotar de la siguiente manera $\sigma(m) = (m(\xi_M), m(\xi_M^3),...,m(\xi_M^{2N-1}))=(z_1,...,z_N)$.
Las potencias son $i/gcd(i,M)=1$, con el $M$ del polinomio ciclotomico.

\todo[inline]{por que hace esos saltos usando gcd? Tiene algo que ver con las raices de la unidad}

A esta transformacion se la conoce como encaje canonico.
Que no es otra cosa que dado un polinomio, lo evalua en las distintas raices de la unidad $\xi_M$.
Por cada evaluacion me genera un valor complejo.
Algo a destacar es que como trabajamos en  $R$, es decir polinomios con coeficientes enteros,
vamos a tener la propiedad de $m(\xi^j)=\overline{m(\xi^j)}=m(\overline{\xi^j})$.
Esto quiere decir que cualquier elemento de $\sigma(R)$ tiene efectivamente dimension
$N/2$ y no $N$.
Esta propiedad ya nos reduce la imagen de esta funcion.
Es decir al evaluar en las $N$ raices de la unidad los polinomios $\mathbb{R}$ vamos a
obter  un espacio de dimension $N/2$ y no de $N$, es decir este es la dimension del espacio
$\sigma(\mathbb{R})$.

Esta transformacion es inversible si tomamos algunas concideranciones y entonces tenemos el camino inverso, obteniendo asi un
isomorfismo entre el espacio de los vectores complejos y el espacio de los polinomios de grado
$N/2 -1$.
%Es decir entre $\mathbb{C}^{N}$ y $\mathbb{C}[X]/(X^N+1)$, el cual se resuelve simplemente
%al resolver el sistema de ecuaciones lineales $A\alpha=z$, donde $A$ es la
%matriz de vandermonde para las raices de la unidad y $z$ el input,
%Con $\alpha$ son los coeficientes del polinomio codificado.
%Aca se busca tener un isomorfismo entre $\mathbb{C}^{N/2}$ y
%$\mathbb{Z}[X]/(X^N+1)$.


El primer paso va a ser  querer considerar un input entonces de $N/2$, entonces
para usar el isomorfismo primero lo expandimos de forma espejada con el
complemento conjungado del mismo.
A dicha operacion la denotamos como $\pi^{-1}(z)$.
Y lo que sabemos es que este nuevo areglo va a pertenecer al espacio
$\mathbb{H}=\{z\in\mathbb{C}^N/ \forall j (z_j=\overline{z_j})\}$.

El problema que sigue es poder satisfacer el isomorfismo.
Ya que no es cierto que cualquier elemento de $\mathbb{H}$,
esta en $\sigma(R)$.
Solo sabemos que $\sigma(R)\subseteq \mathbb{H}$.
Entonces para poder tener el isomorfismo que queremos, de $R$ y $\sigma(R)$,
se usa el encaje canonico complejo.

Para poder ver que $\mathbb{H}$ y $\sigma(R)$ son distintos, basta con ver que
el espacio $R$ de los polinomios de grado $N$ con coeficientes enteros son un espacio
contable (se hace por induccion, no vi como) y por ende $\sigma(R)$ lo es.
En cambio es facil ver que $\mathbb{H}$ no es contable ya que que es un isomorfismo
a $\mathbb{C}^{N/2}$.
\textit{CREO:} que la mano viene que muchos elementos de $\mathbb{H}$ caen a un mismo $\mathbb{R}$,
entonces para mantener un isomorfismo discretizamos ese valor a uno en el dominio $\sigma(R)$.

Entonces para recapitular lo que tenemos por ahora es que al expandir $\pi^{-1}(z)\in\mathbb{H}$,
pero lo que quiero es $\pi^{-1}(z)\in\sigma(R)$.
Y para hacer esto, simplemente vamos a que $\pi$ ademas projecte a una base ortogonal  $\sigma(R)$.
La base de esta es facil, ya que sabemos que $R$ tiene una base de $(1, X, X^2, ..., X^{N-1})$.
Es decir que la base ortogonal de  $\sigma(R)$ es $(\sigma(1), \sigma(X),..., \sigma(X^{N-1}))=(\beta_1,...,\beta_{N-1})=\beta$.
Que viene de simplemente evaluar a la cada vector de la base $R$ por las distintas raices de la unidad.
Ejemplo para el vector de la base $X^2$, simplemente lo voy evaluando con las distintas raices.
\begin{equation*}
    \sigma(X^2) = ((\xi)^2, (\xi^3)^2, (\xi^5)^2,(\xi^7)^2)
\end{equation*}


Entonces $\pi^{-1}$, lo que hace es que despues de expandirlo, es decir ya un $z\in\mathbb{H}$,
le hace un cambio de base y lo normaliza.
Recordemos como hacer una projeccion.
Para esto usamos la producto interno Hermitiano, el cual no es otra cosa que $<z,w>=\sum z_i\bar{w_i}$.
Si queremos proyectar un vector $v_1$ sobre un vector $v_2$:


\begin{equation*}
    Prject_{v_2}(v_1) = \frac{<v_1,v_2>}{<v_2,v_2>}v_2
    \label{eq:project}
\end{equation*}

Si ahora queremos hacerlo a un espacio vectorial, que tiene la base $\beta$, simplemente
es la sumatoria de lo recien explicado:

\begin{equation*}
    Project_{\beta}(z) = \sum_{i=0}^{N-1}\frac{<z,\beta_i>}{<\beta_i,\beta_i>}\beta_i
    \label{eq:project}
\end{equation*}

En la implementacion de Python, lo que hacen es primero calcular los productos internos
Hermitianos, dejarlas como un vector, es decir $(<z,\beta_1>,...,<z,\beta_{N-1}>)$.
Luego aplicarle el algoritmo de redondeo a cada uno de estos y luego multiplicar por adelante la matriz
de Vandermonde.
Ya que hacer $ Project_{\beta}(z) $ es lo mismo que hacer $A(<z,\beta_1>,...,<z,\beta_{N-1}>)$.
\todo[inline]{No me queda claro el por que puede aplicar el redondeo como en un paso intermedio}
De esta forma tenemos dentro de nuestra base una representacion con valores enteros de nuestros
valores.
La matrix de Vandermonde para las raices de la unidad es:
\begin{equation*}
    A=    \begin{pmatrix}
        | & | &    & | \\
        \beta_1 & \beta_2 & ... & \beta_{N-1}\\
        | & | &    & |
    \end{pmatrix}
    =
    \begin{pmatrix}
        1 & \xi &  \xi^2 & ... & \xi^{N-1} \\
        1 & \xi_3 & \xi_3^2 & ... & \xi_3^{N-1}\\
        \vdots & \vdots & \vdots & ... & \vdots\\
        1 & \xi_{2N-1} & \xi_{2N-1}^2 & ... & \xi_{2N-1}^{N-1}
    \end{pmatrix}
    \label{eq:vandermonde}
\end{equation*}
Donde utilizamos la notacion que $\xi_i^j=\xi^{i*j}$.

teniendo nuestro $z$ transformad queda simplemente resolver un sistema de ecuaciones lineales para
obtener los coeficientes del polinomio.
Es decir resolver $A\alpha=z$.
Con esto tendriamos nuestra codificacion lista.
Es decir, la codificacion de z quedaria como $\alpha_1 + \alpha_2 X + ... \alpha_{N-1}X^{N-1}$.

\textit{ToDo:} Por lo que parece es que terminamos haciendo $z'=Az$ y luego resolver
$A\alpha=z'$.
Esto no es otra cosa que encontrar la inversa de $A$ y tener que $\alpha=A^{-1}z'=A^{-1}Az$.
Pero por como es la matriz de vandermonde la inversa no es otra cosa que $A^\dagger$.
Entonces No haria falta ni computar $z'$ con el ultimo paso de multiplicar por $A$ ni despues
tener que resolver la inversa y demas.

Un paso que no se menciono, es que para evitar la perdida de informacion en los redondeos
que se hacen durante la codificacion, es que se multiplica por un coeficiente de
escaleo a nuestro input.
Antes de decodificar se divide por este mismo y listo.
Esto se hace ya que si no al redondear en las diferentes etapas se puede perder informacion.

\subsubsection{DFT}
Podemos ver que la matriz $A$  y la matriz de la transformacion de Fourier discreta,
son muy parecidas con la excepcion que la matris $A$ va con otras potencias fila a fila.
DFT va de 1 a $N-1$  y encambio $A$ va haciendo saltos tal que $gcd(i,M)=1$.

\subsubsection{Ejemplo}

Tomemos un ejemplo chico y hagamos las cuentas!
Sea $N=4$ y de entrada vamos a usar $z=[3,4]$.
Sea el factor de escaleo $\Delta=64$.

El primer paso es expandirlo espenandolo y conjugandolo (en este caso es todo real).
A su vez se lo multiplica por  $\Delta$.
\begin{equation*}
    [3,4]\rightarrow [3,4,4,3] \rightarrow [192, 256, 256, 192]
\end{equation*}

Tenemos que nuestra matriz de Vandermonde $A$ es igual a:
\begin{equation*}
    A=
    \begin{pmatrix}
        1 & \xi &  \xi^2 &  \xi^3 \\
        1 & \xi_3 & \xi_3^2 &\xi_3^3\\
        1 & \xi_5 & \xi_5^2 &\xi_5^3\\
        1 & \xi_7 & \xi_7^2 &\xi_7^3
    \end{pmatrix}
    \label{eq:vandermonde_ej}
\end{equation*}

La diagonal de esta matriz al cuadrado es siempre 4.
Entonces tenemos que computar $A\lceil A^\dagger z/4  \rfloor$.

Esto nos da $\lceil(224, -22.62..., -3,5...10^{-15}, 22.62)\rfloor$, y al redondearlo
con el algoritmo estadistito llegamos por ejemplo a $\hat{z}=(224, -23, 0, 23)$.
El elemento 1 y 3 pueden ser tambien $-22$ y/o $22$.


Ahora queda multiplicar por la matriz $A$, para recuperar el input pero que preserva
el isomorfismo.
Realizamos $A\hat{z}$.
Esto nos da un hermoso vector complejo:

\begin{equation*}
    z'= A\hat{z}=
    \begin{pmatrix}
        191.4730... + 3.5....10^{-15}i \\
        256.52... - 2.13....10^{-14}i \\
        256.52... - 3.907....10^{-14}i \\
        191.4730... + 4.61....10^{-14}i
    \end{pmatrix}
    \label{eq:vandermonde_ej}
\end{equation*}

Para finalizar, hay que resolver $A\alpha = z'$.
Si metemos en Python y resolvemos y a esto le tomamos parte real y redondeamos
(esta vez de forma estandar, no con el algoritmo de redondeamiento estadistico).
La solucion queda

\begin{equation*}
    \alpha = (224, -23, 0, 23)
\end{equation*}

Es decir el polinomio que representa la codificacion de nuestro valor de entrada es:


\begin{equation*}
    codificacion(z) = m(X) = 23X^3+0X^0-23X+224
\end{equation*}

Para recuperar nuestro input, es decir para decodificarlo, lo que se hace es
evaluar este polinomio en las diferentes racies, es decir $\xi=e^{i2\pi/8 }$.

\begin{equation*}
    decodificacion(z) = ( m(\xi), m(\xi^3), m(\xi^5), m(\xi^7)) \approx z
\end{equation*}

Recordamos que es un aproximado ya que el propio esquema lo es debido a las diferentes
redondeos que suceden.

\subsubsection{Dudas}
\begin{itemize}
  \item Cuando realmente tengo un elemento que requiere hacer esa projeccion raro? Por que en principio siempre que pruebo, solo con redondear me da los coeficientes...
  Osea sin multplicar por la matriz dagada, ni resolver el sistemas de ecuaciones para obtener alpha... raro
\end{itemize}
Solucion

Creo que la mano viene asi, basicamente al querer resolver $A\alpha=z'$ es resolver $\alpha=A^{-1}z'$.
Pero recordemos que era ese $z'$, no es otra cosa que $A\lceil A^{\dagger}(z/norm)\rfloor$.
Donde ese $norm$ es la normalizacion, que por ser este tipo de matriz, es un mismo valor para cada caso.
Entonces en el caso general tenemos que $\alpha=A^{-1}A\lceil A^{\dagger}(z/norm)\rfloor$

Ya vemos que la primer parte $A^{-1}A$ es la identidad....
Entonces nos queda que $\alpha=\lceil A^{\dagger}(z/norm)\rfloor$.
Entonces no se para que hacen esta cuenta de mas.... simplemente los alphas son
los que me dan al realziar esa cuenta.

Otra cosa que tambien sale, es que la normalizacion de la matriz esta, es simplemente el tamano que tiene...
La matriz dagada de A dividida por la normalizacion, es justamente la matriz inversa de A, y por eso queda como
resolver directamente... Solo queda de nuevo el algoritmo de aproximizacion.

Se agrega entonces la duda de que es el encaje canonico.....



\subsection{Aprendice}
\subsubsection{Lattices}
Basicamente el crear como creamos las matrices random A de la public key, y demas
es sobre esto.

Dado una base (como cuando usamos $\sigma$ en el encoding), queremos encontrar
coeficientes enteros no triviales que hacen cero la suma.

\href{https://www.youtube.com/watch?v=FVFw_qb1ZkY}{link}
\subsubsection{Producto interno}
Sea nuestro input $z=(i, j)$ y nuestra matriz $A$:

\begin{equation*}
    A=
    \begin{pmatrix}
        a & b  \\
        c & c
    \end{pmatrix}
    \label{eq:ejA}
\end{equation*}

Entonces hacer $<z,b_i>b_i$ nos quedaria:

\begin{equation*}
    \begin{split}
        &<(i,j),(a,c)>(a,c) + <(i,j),(b,d)>(b,d) \\
        &=(i\overline{a} + j\overline{c})(a,c)+(i\overline{b} + j\overline{d})(b,d)\\
        &=((i\overline{a} + j\overline{c})a,(i\overline{a} + j\overline{c})c)+((i\overline{b} + j\overline{d})b,(i\overline{b} + j\overline{d})d)\\
        &= ((i\overline{a} + j\overline{c})a+(i\overline{b} + j\overline{d})b,(i\overline{a} + j\overline{c})c,(i\overline{b} + j\overline{d})d)
    \end{split}
    \label{eq:ej}
\end{equation*}

y esto es analogo a hacer $Az\overline{A}$, donde la ultima matriz es $A$ conjugada.


\subsubsection{DFT}
La transformada inversa discreta de Fourier no es otra cosa que una serie del estilo:

\begin{equation*}
    f_k = \sum_{j=0}^{N-1}\hat{f}_je^{i2\pi j k/N}
\end{equation*}

Donde las $f_k$ son los datos que tengo de la funcion original, y $\hat{f}_j$ son
las componentes en el espacio de frecuencia.
Vamos a tener $N$ elementos.
Si definimos $w_N=e^{-i2\pi/N}$, podemos escribirlo de forma matricial:
\begin{equation*}
    \begin{pmatrix}
         f_1 \\
         f_2 \\
        \vdots \\
          f_{N-1}
    \end{pmatrix}
    =
    \begin{pmatrix}
        1 & 1 &  1 & ... & 1 \\
        1 & w_N &  w_N^2 & ... & w_N^{N-1} \\
        1 & w_N^2 & w_N^4 & ... & w_N^{2(N-1)}\\
        \vdots & \vdots & \vdots & ... & \vdots\\
        1 & w_N^{n-1} & w_N^{2(N-1)} & ... & w_N^{(N-1)^2}
    \end{pmatrix}
    \label{eq:vandermonde}
    \begin{pmatrix}
        \hat{f}_1 \\
         \hat{f}_2 \\
        \vdots \\
          \hat{f}_{N-1}
    \end{pmatrix}
\end{equation*}


\end{document}
% https://bit-ml.github.io/blog/post/homomorphic-encryption-toy-implementation-in-python/

